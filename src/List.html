<svelte:window on:keydown="handleKeyDown(event)"/>

<div class="listContainer" ref:container>
    {#each items as item, i}
    <div on:mouseover="handleHover(item)" on:click="handleClick(item, event)"
         class="listItem {itemClasses(hoverItemIndex, item, item.index, items, selectedItem)}">
        <svelte:component this="{Item}" {item}/>
    </div>
    {:else}
    <div class="empty">No options</div>
    {/each}
</div>

<style>
    .listContainer {
        box-shadow: 0 2px 3px 0 rgba(44, 62, 80, 0.24);
        border-radius: 4px;
        max-height: 250px;
        overflow-y: auto;
        background: #fff;
    }

    .listItem {
        height: 40px;
        line-height: 40px;
        padding: 0 20px;
        text-overflow: ellipsis;
        overflow-x: hidden;
        white-space: nowrap;
    }

    .listItem.hover {
        background: #e7f2ff;
    }

    .listItem:active {
        background: #b9daff;
    }

    .listItem:first-child {
        border-radius: 4px 4px 0 0;
    }

    .listItem.active {
        background: #007aff;
        color: #fff;
    }

    .empty {
        text-align: center;
        padding: 20px 0;
        color: #78848F;
    }
</style>

<script>
  import Item from './Item.html';

  export default {
    data() {
      return {
        hoverItemIndex: 0,
        items: [],
        Item,
        disableMouseHover: false,
        selectedItem: undefined
      }
    },
    onupdate({changed, current, previous}) {
      if (changed.items && current.items.length > 0) {
        this.scrollToActiveItem('hover');
        if (!current.items.find((item) => item.index === current.hoverItemIndex)) {
          this.set({
            hoverItemIndex: current.items[0].index,
            disableMouseHover: false
          })
        }
      }
      if (changed.activeItemIndex && current.activeItemIndex > -1) {
        this.scrollToActiveItem('active');
        this.set({
          hoverItemIndex: current.activeItemIndex,
        })
      }
      if (changed.selectedItem && current.selectedItem) {
        this.scrollToActiveItem('active');
        if (current.items) {
          const hoverItem = current.items.find(item => item.value === current.selectedItem.value);
          if (hoverItem) {
            this.set({hoverItemIndex: hoverItem.index});
          }
        }
      }

    },
    helpers: {
      itemClasses(hoverItemIndex, item, itemIndex, items, selectedItem) {
        return `${selectedItem && (selectedItem.value === item.value) ? 'active ' : ''}${hoverItemIndex === itemIndex || items.length === 1 ? 'hover' : ''}`;
      }
    },
    methods: {
      handleSelect(item) {
        this.fire('itemSelected', item);
      },
      handleHover(item) {
        const {disableMouseHover} = this.get();
        if (!disableMouseHover) {
          this.set({hoverItemIndex: item.index});
        } else {
          this.set({disableMouseHover: false})
        }
      },
      handleClick(item, event) {
        event.stopPropagation();
        this.set({activeItemIndex: item.index, hoverItemIndex: item.index});
        this.handleSelect(item);
      },
      updateHoverItem(increment) {
        let {items, hoverItemIndex} = this.get();

        if (increment > 0 && hoverItemIndex === (items.length - 1)) {
          hoverItemIndex = 0;
        }
        else if (increment < 0 && hoverItemIndex === 0) {
          hoverItemIndex = items.length - 1;
        }
        else {
          hoverItemIndex = hoverItemIndex + increment;
        }

        this.set({items, hoverItemIndex})
      },
      handleKeyDown(e) {
        const {items, hoverItemIndex} = this.get();
        switch (e.key) {
          case 'ArrowDown':
            e.preventDefault();
            this.updateHoverItem(1);
            break;
          case 'ArrowUp':
            e.preventDefault();
            this.updateHoverItem(-1);
            break;
          case 'Enter':
            e.preventDefault();
            this.set({activeItemIndex: hoverItemIndex});
            this.handleSelect(items[hoverItemIndex]);
            break;
          case 'Tab':
            e.preventDefault();
            this.set({activeItemIndex: hoverItemIndex});
            this.handleSelect(items[hoverItemIndex]);
            break;
        }
      },
      scrollToActiveItem(className) {
        this.set({disableMouseHover: true});
        const {container} = this.refs;
        let offsetBounding;
        const focusedElemBounding = container.querySelector(`.listItem.${className}`);
        if (focusedElemBounding) {
          offsetBounding = container.getBoundingClientRect().bottom - focusedElemBounding.getBoundingClientRect().bottom;
        }
        container.scrollTop -= offsetBounding;
      }
    }
  }
</script>

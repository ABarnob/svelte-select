<svelte:window on:keydown="handleKeyDown(event)"/>

<div class="container" ref:container>
    {#each items as item}
    <div class="listItem {item.active ? 'active' : ''}">{item.name}</div>
    {:else}
    <div class="empty">So</div>
    {/each}
</div>

<style>
    .container {
        box-shadow: 0 2px 3px 0 rgba(44, 62, 80, 0.24);
        border-radius: 4px;
        height: 176px;
        overflow-y: auto;
    }

    .listItem {
        padding: 20px;
    }

    .listItem:hover {
        background: #e7f2ff;
    }

    .listItem:first-child {
        border-radius: 4px 4px 0 0;
    }

    .listItem.active {
        background: #007aff;
        color: #fff;
    }
</style>

<script>
  export default {
    data() {
      return {}
    },
    onupdate({changed, current, previous}) {
      if (changed.items && current.items.length > 0 && this.refs.container) {
        this.scrollToActiveItem()
      }
    },
    methods: {
      updateActiveItem(increment) {
        const {items} = this.get();
        const activeItemIndex = items.findIndex(item => item.active);
        if (activeItemIndex === -1) return;
        items[activeItemIndex].active = false;

        if (increment > 0 && activeItemIndex === (items.length - 1)) {
          items[0].active = true;
        }
        else if (increment < 0 && activeItemIndex === 0) {
          items[items.length - 1].active = true;
        }
        else {
          items[activeItemIndex + increment].active = true;
        }

        this.set({items})
      },
      handleKeyDown(e) {
        switch (e.key) {
          case 'ArrowDown':
            this.updateActiveItem(1);
            break;
          case 'ArrowUp':
            this.updateActiveItem(-1);
            break;
        }
      },
      scrollToActiveItem() {
        const {container} = this.refs;
        let offsetBounding;
        const focusedElemBounding = container.querySelector('.listItem.active');
        if (focusedElemBounding) {
          offsetBounding = container.getBoundingClientRect().bottom - focusedElemBounding.getBoundingClientRect().bottom;
        }
        container.scrollTop -= offsetBounding;
      }
    }
  }
</script>